<!doctype html>
<html>
	<head>
		<title>Главная</title>
		<meta charset="utf-8">
		<link rel="stylesheet" href="styles.css">
		<script src='function.js' defer></script>
		<script src='script.js' defer></script>
	</head>

	<body>
		<div id='navcontainer'>
			<nav id='navigation'>
				<a href='index.html'>Главная</a>
				<a href='description.html'>Описание</a>
				<a href='structures.html'>Структуры Данных</a>
				<a href='contacts.html'>Контакты</a>
			</nav>
		</div>

		
		<div id='maincontainer'>
			<aside id='aside'>
				<a href='#1'>Структуры Данных</a>
				<a href='#2'>Массивы</a>
				<a href='#3'>Списки</a>
				<a href='#4'>Односвязный Список</a>
				<a href='#5'>Двусвязный Список</a>
				<a href='#6'>Кольцевой Список</a>
				<a href='#7'>Стек</a>
				<a href='#8'>Очередь</a>
				<a href='#9'>Дек</a>
				<a href='#10'>Графы</a>
				<a href='#11'>Деревья</a>
			</aside>

			<div id='main'>
				<a name='1'>
				<h1>Структуры Данных</h1>

				<p>
					Необходимым условием хранения информации в памяти
					компьютера является возможность преобразования этой самой
					информации в подходящую для компьютера форму. В том
					случае, если это условие выполняется, следует определить
					структуру, пригодную именно для наличествующей информации,
					ту, которая предоставит требующийся набор возможностей
					работы с ней.
				</p>

				<p>
					Здесь под структурой понимается способ представления информации,
					посредством которого совокупность отдельно взятых
					элементов образует нечто единое, обусловленное их
					взаимосвязью друг с другом. Скомпонованные  по каким-либо
					правилам и логически связанные межу собой, данные могут
					весьма эффективно обрабатываться, так как общая для них
					структура предоставляет набор возможностей управления ими
					– одно из того за счет чего достигаются высокие результаты
					в решениях тех или иных задач.
				</p>

				<p>
					Но не каждый объект представляем в произвольной форме, а
					возможно и вовсе для него имеется лишь один единственный
					метод интерпретации, следовательно, несомненным плюсом для
					программиста будет знание всех существующих структур
					данных. Таким образом, часто приходиться делать выбор
					между различными методами хранения информации, и от такого
					выбора зависит работоспособность продукта.
				</p>

				<p>
					Говоря о не вычислительной технике, можно показать ни один
					случай, где у информации видна явная структура. Наглядным
					примером служат книги самого разного содержания. Они
					разбиты на страницы, параграфы и главы, имеют, как
					правило, оглавление, то есть интерфейс пользования ими. В
					широком смысле, структурой обладает всякое живое существо,
					без нее органика навряд-ли смогла бы существовать.
				</p>

				<p>
					Вполне вероятно, читателю приходилось сталкиваться со
					структурами данных непосредственно в информатике,
					например, с теми, что встроены в язык программирования.
					Часто они именуются типами данных. К таковым относятся:
					массивы, числа, строки, файлы и т.д.
				</p>

				<p>
					Методы хранения информации, называемые «простыми», т. е.
					неделимыми на составные части, предпочтительнее изучать
					вместе с конкретным языком программирования, либо же
					глубоко углубляться в суть их работы. Поэтому здесь будут
					рассмотрены лишь «интегрированные» структуры, те которые
					состоят из простых, а именно: массивы, списки, деревья и графы.
				</p>
				
				<a name='2'>
				<h2>Массивы</h2>
				<p>
					Массив – это структура данных с фиксированным и
					упорядоченным набором однотипных элементов (компонентов).
					Доступ к какому-либо из элементов массива осуществляется
					по имени и номеру (индексу) этого элемента. Количество
					индексов определяет размерность массива. Так, например,
					чаще всего встречаются одномерные (вектора) и двумерные
					(матрицы) массивы.
				</p>

				<p>
					Первые имеют один индекс, вторые – два. Пусть одномерный
					массив называется A, тогда для получения доступа к его
					i-ому элементу потребуется указать название массива и
					номер требуемого элемента: A[i]. Когда A – матрица, то она
					представляема в виде таблицы, доступ к элементам которой
					осуществляется по имени массива, а также номерам строки и
					столбца, на пересечении которых расположен элемент: A[i,j],
					где i – номер строки, j – номер	столбца.
				</p>

				<p>
					В разных языках программирования работа с массивами может в
					чем-то различаться, но основные принципы, как правило,
					везде одни. В языке Pascal, обращение к одномерному и
					двумерному массиву происходит точно так, как это показано
					выше, а, например, в C++ двумерный массив следует
					указывать так: A[i][j]. Элементы массива нумеруются
					поочередно. На то, с какого значения начинается нумерация,
					влияет язык программирования. Чаще всего этим значением
					является 0 или 1.
				</p>

				<p>
					Массивы, описанного типа называются статическими, но
					существуют также массивы по определенным признакам
					отличные от них: динамические и гетерогенные. Динамичность
					первых характеризуется непостоянностью размера, т. е. по
					мере выполнения программы размер динамического массива
					может изменяться. Такая функция делает работу с данными
					более гибкой, но при этом приходится жертвовать
					быстродействием, да и сам процесс
					усложняется.
				</p>

				<p>
					Обязательный критерий статического массива, как было
					сказано, это однородность данных, единовременно хранящихся
					в нем. Когда же данное условие не выполняется, то массив
					является гетерогенным. Его использование обусловлено
					недостатками, которые имеются в предыдущем виде, но оно
					оправданно во многих случаях.
				</p>

				<p>
					Таким образом, даже если Вы определились со структурой, и
					в качестве нее выбрали массив, то этого все же
					недостаточно. Ведь массив это только общее обозначение,
					род для некоторого числа возможных реализаций. Поэтому
					необходимо определиться с конкретным способом
					представления, с наиболее подходящим массивом.
				</p>

				<a name='3'>
				<h2>Списки</h2>
				<p>
					Список – абстрактный тип данных, реализующий упорядоченный
					набор значений. Списки отличаются от массивов тем, что
					доступ к их элементам осуществляется последовательно, в то
					время как массивы – структура данных произвольного
					доступа. Данный абстрактный тип имеет несколько реализаций
					в виде структур данных. Некоторые из них будут рассмотрены здесь.
				</p>

				<p>
					Список (связный список) – это структура данных,
					представляющая собой конечное множество упорядоченных
					элементов, связанных друг с другом посредствам указателей.
					Каждый элемент структуры содержит поле с какой-либо
					информацией, а также указатель на следующий элемент. В
					отличие от массива, к элементам списка нет произвольного
					доступа.
				</p>

				<a name='4'>
				<h2>Односвязный список</h2>
				<p>
					В односвязном списке, приведенным выше, начальным
					элементом является Head list (голова списка [произвольное
					наименование]), а все остальное называется хвостом. Хвост
					списка составляют элементы, разделенные на две части:
					информационную (поле info) и указательную (поле next). В
					последнем элементе вместо указателя, содержится признак
					конца списка – nil.
				</p>

				<p>
					Односвязный список не слишком удобен, т. к. из одной точки
					есть возможность попасть лишь в следующую точку, двигаясь
					тем самым в конец. Когда кроме указателя на следующий
					элемент есть указатель и на предыдущий, то такой список
					называется двусвязным.
				</p>

				<a name='5'>
				<h2>Двусвязный список</h2>
				<p>
					Возможность двигаться как вперед, так и назад полезна для
					выполнения некоторых операций, но дополнительные указатели
					требуют задействования большего количества памяти, чем
					таковой необходимо в эквивалентном односвязном
					списке.
				</p>

				<p>
					Для двух видов списков описанных выше существует подвид,
					называемый кольцевым списком. Сделать из односвязного
					списка кольцевой можно добавив всего лишь один указатель в
					последний элемент, так чтобы он ссылался на первый. А для
					двусвязного потребуется два указателя: на первый и
					последний элементы.
				</p>

				<a name='6'>
				<h2>Кольцевой список</h2>
				<p>
					Помимо рассмотренных видов списочных структур есть и другие
					способы организации данных по типу «список», но они, как
					правило, во многом схожи с разобранными, поэтому здесь они
					будут опущены.
				</p>

				<p>
					Кроме различия по связям, списки делятся по методам работы
					с данными. О некоторых таких методах сказано далее.
				</p>

				<a name='7'>
				<h2>Стек</h2>
				<p>
					Стек характерен тем, что получить доступ к его элементом
					можно лишь с одного конца, называемого вершиной стека,
					иначе говоря: стек – структура данных, функционирующая по
					принципу LIFO (last in — first out, «последним пришёл —
					первым вышел»). Изобразить эту структуру данных лучше в
					виде вертикального списка, например, стопки каких-либо
					вещей, где чтобы воспользоваться одной из них нужно
					поднять все те вещи, что лежат выше нее, а положить
					предмет можно лишь на вверх стопки.
				</p>

				<p>
					В показанном односвязном списке операции над элементами
					происходят строго с одного конца: для включения нужного
					элемента в пятую по счету ячейку необходимо исключить тот
					элемент, который занимает эту позицию. Если бы было,
					например 6 элементов, а вставить конкретный элемент
					требовалось также в пятую ячейку, то исключить бы пришлось
					уже два элемента.
				</p>

				<a name='8'>
				<h2>Очередь</h2>
				<p>
					Структура данных «Очередь» использует принцип организации
					FIFO (First In, First Out — «первым пришёл — первым
					вышел»). В некотором смысле такой метод более справедлив,
					чем тот, по которому функционирует стек, ведь простое
					правило, лежащее в основе привычных очередей в различные
					магазины, больницы считается вполне справедливым, а именно
					оно является базисом этой структуры. Пусть данное
					наблюдение будет примером. Строго говоря, очередь – это
					список, добавление элементов в который допустимо, лишь в
					его конец, а их извлечение производиться с другой стороны,
					называемой началом списка.
				</p>

				<a name='9'>
				<h2>Дек</h2>
				<p>
					Дек (deque — double ended queue, «двухсторонняя очередь»)
					– стек с двумя концами. Действительно, несмотря конкретный
					перевод, дек можно определять не только как двухстороннюю
					очередь, но и как стек, имеющий два конца. Это означает,
					что данный вид списка позволяет добавлять элементы в
					начало и в конец, и то же самое справедливо для операции
					извлечения.
					Дек
				</p>

				<p>
					Эта структура одновременно работает по двум способам организации
					данных: FIFO и LIFO. Поэтому ее допустимо отнести к
					отдельной программной единице, полученной в результате
					суммирования двух предыдущих видов списка.
				</p>

				<a name='10'>
				<h2>Графы</h2>
				<p>
					Раздел дискретной математики, занимающийся изучением
					графов, называется теорией графов. В теории графов
					подробно рассматриваются известные понятия, свойства,
					способы представления и области применения этих
					математических объектов. Нас же интересует, лишь те ее
					аспекты, которые важны в программировании.
				</p>

				<p>
					Граф – совокупность точек, соединенных линиями. Точки
					называются вершинами (узлами), а линии – ребрами (дугами).
				</p>

				<p>
					Как показано на рисунке различают два основных вида графов:
					ориентированные и неориентированные. В первых ребра
					являются направленными, т. е. существует только одно
					доступное направление между двумя связными вершинами,
					например из вершины 1 можно пройти в вершину 2, но не
					наоборот. В неориентированном связном графе из каждой
					вершины можно пройти в каждую и обратно. Частный случай
					двух этих видов – смешанный граф. Он характерен наличием
					как ориентированных, так и неориентированных ребер.
				</p>

				<p>
					Степень входа вершины – количество входящих в нее ребер,
					степень выхода – количество исходящих ребер.
				</p>

				<p>
					Ребра графа необязательно должны быть прямыми, а вершины
					обозначаться именно цифрами, так как показано на рисунке.
					К тому же встречаются такие графы, ребрам которых
					поставлено в соответствие конкретное значение, они
					именуются взвешенными графами, а это значение – весом
					ребра. Когда у ребра оба конца совпадают, т. е. ребро
					выходит из вершины F и входит в нее, то такое ребро
					называется петлей.
				</p>

				<p>
					Графы широко используются в структурах, созданных
					человеком, например в компьютерных и транспортных сетях,
					web-технологиях. Специальные способы представления
					позволяют использовать граф в информатике (в
					вычислительных машинах). Самые известные из них: «Матрица
					смежности», «Матрица инцидентности», «Список смежности»,
					«Список рёбер». Два первых, как понятно из названия, для
					репрезентации графа используют матрицу, а два последних –
					список.
				</p>

				<a name='11'>
				<h2>Деревья</h2>
				<p>
					Дерево как математический объект это абстракция из
					соименных единиц, встречающихся в природе. Схожесть
					структуры естественных деревьев с графами определенного
					вида говорит о допущении установления аналогии между ними.
					А именно со связанными и вместе с этим ациклическими (не
					имеющими циклов) графами. Последние по своему строению
					действительно напоминают деревья, но в чем то и имеются
					различия, например, принято изображать математические
					деревья с корнем расположенным вверху, т. е. все ветви
					«растут» сверху вниз. Известно же, что в природе это
					совсем не так.
				</p>

				<p>
					Поскольку дерево это по своей сути граф, у него с последним
					многие определения совпадают, либо интуитивно схожи. Так
					корневой узел (вершина 6) в структуре дерева – это
					единственная вершина (узел), характерная отсутствием
					предков, т. е. такая, что на нее не ссылается ни какая
					другая вершина, а из самого корневого узла можно дойти до
					любой из имеющихся вершин дерева, что следует из свойства
					связности данной структуры. Узлы, не ссылающиеся ни на
					какие другие узлы, иначе говоря, ни имеющие потомков
					называются листьями (2, 3, 9), либо терминальными узлами.
					Элементы, расположенные между корневым узлом и листьями –
					промежуточные узлы (1, 1, 7, 8). Каждый узел дерева имеет
					только одного предка, или если он корневой, то не имеет ни
					одного.
				</p>

				<p>
					Поддерево – часть дерева, включающая некоторый корневой
					узел и все его узлы-потомки. Так, например, на рисунке
					одно из поддеревьев включает корень 8 и элементы 2, 1, 9.
				</p>

				<p>
					С деревом можно выполнять многие операции, например,
					находить элементы, удалять элементы и поддеревья,
					вставлять поддеревья, находить корневые узлы для некоторых
					вершин и др. Одной из важнейших операций является обход
					дерева. Выделяются несколько методов обхода. Наиболее
					популярные из них: симметричный, прямой и обратный обход.
					При прямом обходе узлы-предки посещаются прежде своих
					потомков, а в обратном обходе, соответственно, обратная
					ситуация. В симметричном обходе поочередно просматриваются
					поддеревья главного дерева.
				</p>

				<p>
					Представление данных в рассмотренной структуре выгодно в
					случае наличия у информации явной иерархии. Например,
					работа с данными о биологических родах и видах, служебных
					должностях, географических объектах и т. п. требует
					иерархически выраженной структуры, такой как
					математические деревья
				</p>
			</div>
		</div>
		
	</body>

</html>
